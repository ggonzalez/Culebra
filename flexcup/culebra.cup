package culebra.syntax;

// Declaración de importaciones
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;
import java.io.*;

import culebra.*;
import culebra.lexical.Token;
import culebra.syntax.*;
import culebra.arch.*;
import culebra.arch.sentences.*;
import culebra.arch.sentences.io.*;
import culebra.arch.expressions.*;
import culebra.semantic.*;
import culebra.arch.types.*;
import culebra.arch.variable.*;
import culebra.arch.variable.behaviour.*;
import culebra.arch.variable.storage.*;
import culebra.arch.variable.factories.*;
import culebra.security.arch.*;

action code {:
    SyntaxErrorManager  errorManager = new SyntaxErrorManager();
    ModuleManager   moduleManager = new ModuleManager();
    FunctionManager functionManager = new FunctionManager();
    VariableManager globalVariables = new VariableManager("global");
    VariableManager currentVariables = null;
    Stack           stackIterator = new Stack();

    public Variable getVariable(List ids) {
        if (currentVariables.hasVariable(ids))
            return currentVariables.getVariable(ids);

        if (globalVariables.hasVariable(ids))
            return globalVariables.getVariable(ids);

         return null;
    }
:}

parser code {:
	public void syntax_error(Symbol symbol)
	{
	    Token token = (Token) symbol.value;
	    SyntaxErrorManager.syntaxError ("Error sintactico", token);
	}

	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{
		Token token = (Token) symbol.value;
	    SyntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}


:}

// Declaración de terminales

terminal Token INTEGER;
terminal Token STRING;
terminal Token ID;

// KEYWORDS
terminal Token CASE;
terminal Token DEFINE;
terminal Token BREAK;
terminal Token IMPORT;
terminal Token MODULE;
terminal Token FLUSH;
terminal Token DELETE;
terminal Token HOOKS;
terminal Token AS;

terminal Token ENUM;
//terminal Token PRINTF;
terminal Token ESCRIBEINT;
terminal Token SWITCH;
terminal Token WHILE;
terminal Token FOR;
terminal Token DEFAULT;
terminal Token MAIN;
terminal Token STRUCT;
terminal Token RETURN;
terminal Token CONTINUE;
terminal Token IF;
terminal Token ELSE;
terminal Token TYPEDEF;

// MODIFICATORS
terminal Token TMP;

// TYPES
terminal Token INT;
terminal Token STR;
terminal Token FLT;
terminal Token VOID;
terminal Token VAR;

// DELIMITADORES
terminal Token LPAREN;
terminal Token RPAREN;

terminal Token LCURLY;
terminal Token RCURLY;
terminal Token COMA;
terminal Token SEMICOLON;
terminal Token COLON;
terminal Token ANDPERSAND;

////////////
// Operadores
//
// Aritmeticos
terminal Token PLUS;
terminal Token MINUS;
terminal Token MUL;
terminal Token DIV;

// Relacionales
terminal Token LESS;
terminal Token GREAT;
terminal Token LESSEQUAL;
terminal Token GREATEQUAL;
terminal Token EQUAL;
terminal Token NOEQUAL;

// Logicos
terminal Token AND;
terminal Token OR;
terminal Token NOT;

// Especiales
terminal Token PLUSPLUS;
terminal Token MINUSMINUS;

// Asignacion
terminal Token ASSIG;
terminal Token ADDASSIG;
terminal Token SUBSASSIG;

// I/O Operators
terminal Token PRINTLN;
terminal Token PRINT;
terminal Token READ;

// Access
terminal Token DOT;
terminal Token ITER;

// REGEX
terminal Token REGEX;

// Declaraci�n de no terminales
// no modificar los propuestos

non terminal ModuleManager   	program;
non terminal                	programModule;

non terminal String             importHeader;
non terminal String             moduleHeader;
non terminal ModuleFunction     moduleFunctionName;

non terminal                    body;
non terminal                    declaration;

non terminal                    endLine;

non terminal Variable										dataType;
non terminal List               								dataParamList;
non terminal Variable										dataParam;
non terminal DataBehaviour      						dataBehaviour;
non terminal List              								behaviourParamList;
non terminal BehaviourParam     						behaviourParam;
non terminal VarAttr           				 		    varAttr;

non terminal List											idList;

non terminal List               varListLocal;
non terminal List               varLocal;
non terminal List               varLocalList;
non terminal Sentence           varLocalId;

non terminal Type               type;
non terminal String             modificator;

non terminal Function           function;
non terminal List               functionBodyList;

non terminal List               functionArgsList;
non terminal Variable           functionOneArg;

non terminal FunctionCall       functionCall;
non terminal List               functionCallArgsList;
non terminal Expr               functionCallOneArg;

non terminal	FunctionHook 						functionHooks;
non terminal	List										hookedFunctionList;
non terminal	HookedFunction					hookedFunction;

non terminal SentencesBlock     sentencesBlock;
non terminal Sentence           sentences;
non terminal List               sentencesList;

non terminal Integer				blockRepetition;

non terminal Sentence           assignSentence;
non terminal AddAssig          	addAssig;
non terminal SubAssig         	subAssig;
non terminal While              whileSentence;
non terminal For                forSentence;
non terminal Sentence           forPre, forLoop;
non terminal Expr               forCondition;
non terminal IfSentence			ifSentence;
non terminal Return				returnSentence;

non terminal Println            println;
non terminal Print              print;
non terminal Read               read;

non terminal VariableIterator   iterator;
non terminal FlushVariable      flushVariable;

non terminal Expr               expr;

//// OLD VERSION

non terminal                    seccOp;
non terminal                    seccOpEnd;

non terminal                    declaracion;
non terminal                    declaracionEnd;

non terminal                    funcionDef;
non terminal                    tipoFunc;

non terminal                    funcParam;
non terminal                    funcParamEnd;

non terminal                    localVar;
non terminal                    localType;
non terminal                    sentencesEnd;
non terminal                    sentencesBlockClosed;

non terminal                    sentencesBlockClosedEnd;

non terminal                    tipoDecl;
non terminal                    tipoDeclEnd;

non terminal List               enumeraDef;
non terminal String             enumeraDefEnd;
non terminal                    registroDef;
non terminal                    registroDefEnd;
non terminal                    registroDefDecl;
non terminal                    regMember;

non terminal VarList            varDeclaracion;
non terminal Var                varDeclaracionEnd;

non terminal                    sentenceOpen;
non terminal                    sentenceClosed;
non terminal                    ifSentenceEnd;

non terminal                    switchSentence;


non terminal                    funcCall;
non terminal                    funcCallArgs;
non terminal                    funcCallArgsEnd;

non terminal                    assigSentence;
non terminal                    assigSentenceEnd;

non terminal                    alternativas;
non terminal                    alterBody;
non terminal                    alterBodyEnd;
non terminal                    alterCaso;
non terminal                    alterCasoDefault;

non terminal                    mientras;

non terminal                    para;

precedence  left    DOT,
                    LPAREN,
                    RPAREN;

precedence  left    PLUSPLUS,
                    MINUSMINUS,
                    NOT;

precedence  left    MUL,
                    DIV;

precedence  left    LESS,
                    GREAT,
					LESSEQUAL,
                    GREATEQUAL;
					
precedence  left    EQUAL,
                    NOEQUAL;

precedence  left    AND;

precedence  left    OR;

precedence  left    PLUS,
                    MINUS;
					
precedence	left	ELSE;

///////////////
// Production rules declaration
//
start with program;

program ::= 
programModule   
{:
    moduleManager.addVariableManager(globalVariables);
    moduleManager.setFunctionManager(functionManager);

    RESULT = moduleManager;
:}
  ;

programModule ::=
moduleHeader:mh importHeader:ih
{:
    if (mh != null)
        moduleManager.setName(mh);
    else 
        moduleManager.setName("main");

    if (ih != null) {
        ModuleManager mm = null;

        mm = ModuleParser.parse(ih);

        moduleManager.addImportedModuleManager(mm);
    }
//System.out.println("primera parte");
:}
body
;

importHeader ::=
IMPORT STRING:file endLine
{:
    RESULT = file.getLexeme();
:}
|
{:
    RESULT = null;
:}
;

moduleHeader ::=
MODULE ID:file endLine
{:
    RESULT = file.getLexeme();
:}
|
{:
    RESULT = null;
:}
;

body ::=
body declaration
| declaration
;

endLine ::=
SEMICOLON
|
;
declaration ::=
dataType:dt endLine
{:
    globalVariables.addVariable((Variable)dt);
:}
| function:f
{:
    functionManager.addFunction(f);
:}
;

/////////
idList ::=
idList:idl DOT ID:id
{:
	idl.add(id.getLexeme());
	
	RESULT = idl;
:}
| ID:id
{:
	List l = new LinkedList();
	
	l.add(id.getLexeme());
	
	RESULT = l;
:};
/////////
dataType ::=
VAR ID:id varAttr:va LCURLY dataParamList:dpl RCURLY
{:
	CompositeVariable cv = new CompositeVariable(id.getLexeme());
	StorageFactory		sf = new ListFactory(); // XXX: Hack 
	Storage					sto = null;
	
    sto = sf.createStorage(va);

	{
		Iterator	iter = dpl.iterator();
		
		while (iter.hasNext()) {
			Variable	tmp = (Variable) iter.next();
			
			/*
			 * Only set the Storage to Composite variables
			 * tmp.addStorage(sto);
			 */
			cv.addVariable(tmp);
		}
	}

	cv.addStorage(sto);
	RESULT = (Variable) cv;
:}
;

dataParamList ::=
dataParamList:dpl COMA dataParam:dp
{:
	dpl.add(dp);
	
	RESULT = dpl;
:}
| dataParam:dp
{:
	List	l = new LinkedList();
	l.add(dp);
	RESULT = l;
:}
;

dataParam ::=
dataType:dt
{:
	RESULT = dt;
:}
| ID:id
{:
	SimpleVariable	sv = new SimpleVariable(id.getLexeme());
	sv.addStorage(new RAMStorage());
	RESULT = (Variable) sv;
:}
;
//XXX Refactor this to be more general.
varAttr ::=
LPAREN behaviourParamList:bpl RPAREN
{:
    VarAttr va = null;

    if (bpl != null && bpl.size() > 0) {
        va = new VarAttr(bpl);
    }
    else {
        va = new VarAttr();
    }

    RESULT = va;
:}
|
{:
    VarAttr va = new VarAttr();

    RESULT = va;
:}
;

type ::=
VAR:v
{:
    VarType type = new VarType("var");

    RESULT = (Type) type;
:}
;

/////////
// Local Variable Declarations
//

varListLocal ::=
varListLocal:v1 varLocal:v2
{:
    List l = new LinkedList();

    l.addAll(v1);
    l.addAll(v2);

    RESULT = l;

:}
| varLocal:v
{:
    RESULT = v;
:}
;

varLocal ::=
modificator:m type:t varLocalList:vl endLine
{:
    SyntaxErrorManager.syntaxInfo(m + " ");
    ListIterator iter = vl.listIterator();

    while (iter.hasNext()) {
        Assig tmp = (Assig) iter.next();

        //tmp.getVariable().setType(t);
        //tmp.getVariable().setTmp(true);

        currentVariables.addVariable(tmp.getVariable());
    }

    RESULT = vl;
:}
| type:t varLocalList:vl endLine
{:
    ListIterator iter = vl.listIterator();

    while (iter.hasNext()) {
        Assig tmp = (Assig) iter.next();

        //tmp.getVariable().setType(t);

        currentVariables.addVariable(tmp.getVariable());
    }

    RESULT = vl;
:}
;

varLocalList ::=
varLocalList:vl COMA varLocalId:v
{:
    List l = new LinkedList();

    l.addAll(vl);
    l.add(v);

    RESULT = l;
:}
| varLocalId:v
{:
    List l = new LinkedList();

    l.add(v);

    RESULT = l;
:}
;

varLocalId ::=
ID:id
{:
    Assig a = new Assig();
    /** XXX: Now variables are all ProxyVariable so they point to Vars instead of containing expr
	Variable var = new SimpleVariable(new VarField(id.getLexeme()));
    Storage sto = new RAMStorage();
    var.addStorage(sto);
	*/
    a.setVariable(new ProxyVariable(id.getLexeme()));

    RESULT = a;
:}
| ID:id ASSIG expr:e
{:
    Assig a = new Assig();
	/** XXX same as above
    Variable var = new SimpleVariable(new VarField(id.getLexeme()));
    Storage sto = new RAMStorage();
    var.addStorage(sto);
	*/
    a.setVariable(new ProxyVariable(id.getLexeme()));
    a.setExpr(e);

    RESULT = a;
:}
;

/////////
// Function Declaration
//

functionHooks ::=
COLON HOOKS LPAREN hookedFunctionList:hfl RPAREN
{:
	FunctionHook	fh = new FunctionHook();
	Iterator				iter = hfl.iterator();
	
	while (iter.hasNext()) {
		HookedFunction	tmp = (HookedFunction) iter.next();
		
		if (tmp.isNoHooked())
			fh.addNoHookedFunction(tmp);
		else
			fh.addHookedFunction(tmp);
	}
	
	RESULT = fh;
:}
|
{:
	FunctionHook	fh = new FunctionHook();
	
	RESULT = null;
:}
;

hookedFunctionList ::=
hookedFunctionList:hfl COMA hookedFunction:hf
{:
	hfl.add(hf);
	
	RESULT = hfl;
:}
| hookedFunction:hf
{:
	List	l = new LinkedList();
	l.add(hf);
	
	RESULT = l;
:}
;

hookedFunction ::=
STRING:s
{:
	HookedFunction	hf = new HookedFunction(s.getLexeme(), false);
	
	RESULT = hf;
:}
| MINUS STRING:s
{:
	HookedFunction	hf = new HookedFunction(s.getLexeme(), true);
	
	RESULT = hf;
:}
;

function ::=
ID:id
{:
	// XXX: Check duplicated function declarations.
    VariableManager vm = new VariableManager(id.getLexeme());
    currentVariables = vm;
    moduleManager.addVariableManager(vm);
:}
LPAREN functionArgsList:fal RPAREN functionHooks:fh functionBodyList:fbl endLine
{:
    SyntaxErrorManager.syntaxInfo("Function: " + id.getLexeme());
    Function func = new Function(id.getLexeme());

    func.addSentences(fbl);
    func.setArguments(fal);
	func.setModuleName(moduleManager.getName());

	if (fh != null) {
		fh.setFunction(func);
		HookManager.addHook(fh);
	}
	
    RESULT = func;
:}
;

functionArgsList ::=
functionArgsList:fal COMA functionOneArg:foa
{:
    List l = new LinkedList();

    l.addAll(fal);
    l.add(foa);

    RESULT = l;
:}
| functionOneArg:foa
{:
    List l = new LinkedList();

    l.add(foa);

    RESULT = l;
:}
|
{:
    List    l = new LinkedList();

    RESULT = l;
:}
;

// XXX: We restrict the use of arguments to Simple Variables
//
functionOneArg ::=
type:t ID:id
{:
    Variable var = new ProxyVariable(id.getLexeme());

    currentVariables.addVariable(var);

    RESULT = var;
:}
;

functionBodyList ::=
LCURLY varListLocal:vl sentencesList:sl RCURLY
{:
    List l = new LinkedList();

    l.addAll(vl);
    l.addAll(sl);

    RESULT = l;
:}
| LCURLY sentencesList:sl RCURLY
{:
    RESULT = sl;
:}
| LCURLY RCURLY
{:
    List ret = new LinkedList();

    RESULT = ret;
:}
|
{:
    List ret = new LinkedList();

    RESULT = ret;
:}
;

sentencesList ::=
sentencesList:sl sentences:s
{:
    List ret = new LinkedList();

    ret.addAll(sl);
    ret.add(s);

    RESULT = ret;
:}
| sentences:s
{:
    List ret = new LinkedList();

    ret.add(s);

    RESULT = ret;
:}
;

sentences ::=
sentencesBlock:sb
{:
    RESULT = (Sentence) sb;
:}
| assignSentence:a endLine
{:
    RESULT = a;
:}
| addAssig:pa endLine
{:
    RESULT = (Sentence) pa;
:}
| subAssig:ma endLine
{:
    RESULT = (Sentence) ma;
:}
| whileSentence:ws endLine
{:
    RESULT = (Sentence) ws;
:}
| forSentence:fs endLine
{:
    RESULT = (Sentence) fs;
:}
| iterator:i
{:
    RESULT = (Sentence) i;
:}
| functionCall:f endLine
{:
    RESULT = (Sentence) f;
:}
| println:p endLine
{:
    RESULT = p;
:}
| print:p endLine
{:
    RESULT = p;
:}
| flushVariable:fv
{:
    RESULT = (Sentence) fv;
:}
| ifSentence:ifs
{:
	RESULT = (Sentence)ifs;
:}
| returnSentence:rs endLine
{:
	RESULT = (Sentence) rs;
:}
;

sentencesBlock ::=
LCURLY varLocal:vl sentencesList:sl RCURLY blockRepetition:br
{:
    SentencesBlock sb = new SentencesBlock();
    List    l = new LinkedList();

    l.addAll(vl);
    l.addAll(sl);

    sb.setSentences(l);
    sb.setRepetitions(Math.abs(br.intValue()));
	System.out.println("SETS " + br);

    RESULT = sb;
:}
| LCURLY sentencesList:sl RCURLY blockRepetition:br
{:
    SentencesBlock sb = new SentencesBlock();
    
	sb.setSentences(sl);
	sb.setRepetitions(Math.abs(br.intValue()));
	System.out.println("SETS " + br);

    RESULT = sb;
:}
| LCURLY RCURLY
{:
    SentencesBlock sb = new SentencesBlock();
    sb.setSentences(new LinkedList());

    RESULT = sb;
:}
;

blockRepetition ::=
MUL INTEGER:num 
{:
	RESULT = new Integer(num.getLexeme());
:}
|
{:
	RESULT = new Integer(1);
:}
;

////////
// Sentences
//

assignSentence ::=
idList:idl ASSIG expr:e
{:
    if (!globalVariables.hasVariable(idl) &&
        !currentVariables.hasVariable(idl)) {
        errorManager.syntaxFatalError("Variable not found: " + idl.toString());
    }
    Assig a = new Assig();

    a.setVariable(getVariable(idl));
    a.setExpr(e);

    RESULT = (Sentence) a;
:}
;

//
//;

whileSentence ::=
WHILE LPAREN expr:e RPAREN sentencesBlock:sb
{:

    While w = new While();
    w.setCondition(e);
if (e == null)
    System.out.println("QUE OXTIAS");
    w.setBlock(sb);

    RESULT = w;
:} 
;

forSentence ::=
FOR LPAREN forPre:fp SEMICOLON forCondition:fc SEMICOLON forLoop:fl RPAREN sentencesBlock:sb
{:
    For f = new For(fp, fc, fl);
    f.setBlock(sb);

    RESULT = f;
:}
;

forPre ::=
assignSentence:as
{:
    RESULT = as;
:}
|
{:
    RESULT = null;
:}
;

forCondition ::=
expr:e
{:
    RESULT = e;
:}
;

forLoop ::=
assignSentence:as
{:
    RESULT = as;
:}
|
{:
    RESULT = null;
:}
;

ifSentence ::=
IF LPAREN expr:e RPAREN sentences:s
{:
	IfSentence	is = new IfSentence();
	
	is.setExpr(e);
	is.setSentence1(s);
	
	RESULT = is;
:}
//| IF LPAREN expr RPAREN sentences ELSE IF LPAREN expr RPAREN sentences
| IF LPAREN expr:e RPAREN sentences:s1 ELSE sentences:s2
{:
	IfSentence	is = new IfSentence();
	
	is.setExpr(e);
	is.setSentence1(s1);
	is.setSentence2(s2);
	
	RESULT = is;
:}
| error ELSE
{:
	System.out.println("ERROR EN ELSE");
:}
;

////////
// Iterator handler
// 

iterator ::=
ITER idList:idl varAttr:va AS ID:idIter
{:
    VariableManager vm = null;

    if (!globalVariables.hasVariable(idl) &&
        !currentVariables.hasVariable(idl)) {
        errorManager.syntaxFatalError("Variable not found: " + idl.toString());
    }
//System.out.println("iterator " + id.getLexeme() + " " + va.isEmpty());
    Variable    var = getVariable(idl);
    Variable    newvar = null;

	newvar = new ProxyVariable(idIter.getLexeme());

	vm = currentVariables;
    vm.addVariable(newvar);

    VariableIterator iter = new VariableIterator(vm, var, newvar, va);

    stackIterator.push(iter);
:}
sentencesBlock:sb
{:
    VariableIterator    iter = (VariableIterator) stackIterator.pop();

    iter.setSentences(sb);
	
    (iter.getVariableManager()).delVariable(iter.getNewvar());

    RESULT = iter;
:}
;

///////
// Flush Variables
// 

flushVariable ::=
idList:idl DOT FLUSH endLine
{:
    if (!globalVariables.hasVariable(idl) &&
        !currentVariables.hasVariable(idl)) {
        errorManager.syntaxFatalError("Variable not found: " + idl.toString());
    }

    FlushVariable fb = new FlushVariable(getVariable(idl));
    
    RESULT = fb;
:}
;
///////
// I/O Sentences
//

//sentencesIO ::=
//;

println ::=
PRINTLN LPAREN expr:e RPAREN
{:
    Println ret = new Println(e);

    RESULT = ret;
:}
;

print ::=
PRINT LPAREN expr:e RPAREN
{:
    Print ret = new Print(e);

    RESULT = ret;
:}
;

read ::=
READ LPAREN RPAREN
{:
    Read ret = new Read();

    RESULT = ret;
:}
;

///////
// ReturnSentence
//

returnSentence ::=
RETURN expr:e
{:
	Return r = new Return(e);
	
	RESULT = r;
:}
;

///////
// Expression
//

expr ::=
  idList:idl
{:
    if (!globalVariables.hasVariable(idl) &&
        !currentVariables.hasVariable(idl)) {
        errorManager.syntaxFatalError("Variable not found: " + idl.toString());
    }

    Variable    var = getVariable(idl);

    RESULT = (Expr) var;
:}
| INTEGER:i
{:
    IntegerExpr exp = new IntegerExpr(i.getLexeme());

    RESULT = (Expr) exp;
:}
| STRING:s
{:
    StringExpr e = new StringExpr(s.getLexeme());

    RESULT = (Expr) e;
:}
| functionCall:f
{:
    RESULT = (Expr) f;
:}
| read:r
{:
    RESULT = (Expr) r;
:}
| expr:e PLUSPLUS
{:
	PostCrement pc = new PostCrement(e, 1);
	
	RESULT = (Expr) pc;
:}
| expr:e MINUSMINUS
{:
	PostCrement pc = new PostCrement(e, -1);
	
	RESULT = (Expr) pc;
:}
| expr:e1 PLUS expr:e2
{:
    Plus p = new Plus(e1, e2);

    RESULT = (Expr) p;
:}
| expr:e1 MINUS expr:e2
{:
    Minus p = new Minus(e1, e2);

    RESULT = (Expr) p;
:}
| expr:e1 LESS expr:e2
{:
    Less l = new Less(e1, e2);

    RESULT = (Expr) l;
:}
| expr:e1 GREAT expr:e2
{:
    Great g = new Great(e1, e2);

    RESULT = (Expr) g;
:}
| expr:e1 LESSEQUAL expr:e2
{:
    LessEqual l = new LessEqual(e1, e2);

    RESULT = (Expr) l;
:}
| expr:e1 GREATEQUAL expr:e2
{:
    GreatEqual g = new GreatEqual(e1, e2);

    RESULT = (Expr) g;
:}
| expr:e1 AND expr:e2
{:
    And a = new And(e1, e2);

    RESULT = (Expr) a;
:}
| expr:e1 OR expr:e2
{:
    Or o= new Or(e1, e2);

    RESULT = (Expr) o;
:}
| expr:e1 EQUAL expr:e2
{:
	Equal eq = new Equal(e1, e2);
	
	RESULT = (Expr) eq;
:}
| expr:e1 NOEQUAL expr:e2
{:
	NoEqual df = new NoEqual(e1, e2);
	
	RESULT = (Expr) df;
:}
| expr:e1 MUL expr:e2
{:
	Mult mu = new Mult(e1, e2);
	
	RESULT = (Expr) mu;
:}
| expr:e1 DIV expr:e2
{:
	Divide div = new Divide(e1, e2);
	
	RESULT = (Expr) div;
:}
| NOT expr
| LPAREN expr:e RPAREN
{:
    RESULT = e;
:}
;

///////////////
// functionCall
//

functionCall ::=
moduleFunctionName:mn LPAREN:l functionCallArgsList:fcal RPAREN
{:
    Function f = null;

    if (mn.isLocalModule()) { 
        if (!functionManager.containsFunction(mn.getFunctionName())) { 
            errorManager.syntaxFatalError("Funtion not declared " + mn.getFunctionName(), l);
        }

        f = functionManager.getFunction(mn.getFunctionName());
    } else {
        FunctionManager fm = null;
        ModuleManager mm = null;

        if (!moduleManager.containsImportedModuleManager(mn.getModuleName())) {
            errorManager.syntaxFatalError("Module \"" + mn.getModuleName() + "\" not imported", l);
        }

        mm = moduleManager.getImportedModuleManager(mn.getModuleName());

        fm = mm.getFunctionManager();

        if (!fm.containsFunction(mn.getFunctionName())) { 
            errorManager.syntaxFatalError("Funtion not declared " + mn.getFunctionName(), l);
        }

       f = fm.getFunction(mn.getFunctionName());
    }
    if (f.getArguments().size() != fcal.size()) {
        errorManager.syntaxFatalError("Bad arguments number ", l);
    }

    FunctionCall fc = new FunctionCall();
    
    fc.setFunction(f);
    fc.setArguments(fcal);
    ListIterator iterArg = f.getArguments().listIterator();
    ListIterator iter = fcal.listIterator();
    while(iter.hasNext()) {
        Expr tmp = (Expr) iter.next();

        Variable varArg = (Variable) iterArg.next();

//        if (var.getType().getName() != varArg.getType().getName()) 
//            errorManager.syntaxFatalError("Variable " + tmp + "type != declaration argument type");
//System.out.println("Value tmp: " + tmp.getValue());
 //       varArg.setValue(tmp.getValue());
    }
    
    RESULT = fc;
:}
;

functionCallArgsList ::=
functionCallArgsList:fl COMA functionCallOneArg:fco
{:
    List    l = new LinkedList();

    l.addAll(fl);
    l.add(fco);

    RESULT = l;
:}
| functionCallOneArg:fco
{:
    List    l = new LinkedList();

    l.add(fco);

    RESULT = l;
:}
|
{:
    List l = new LinkedList();

    RESULT = l;
:}
;

functionCallOneArg ::=
expr:e
{:
    RESULT = e;
:}
;

moduleFunctionName ::=
ID:id1 DOT ID:id2
{:
    ModuleFunction mn = new ModuleFunction();

    mn.setModuleName(id1.getLexeme());
    mn.setFunctionName(id2.getLexeme());

    RESULT = mn;
:}
|ID:id
{:
    ModuleFunction mn = new ModuleFunction();

    mn.setFunctionName(id.getLexeme());

    RESULT = mn;
:}
;
